/* tslint:disable */
/* eslint-disable */
/**
 * GongmuIn API
 * 공무인 API 명세서
 *
 * The version of the OpenAPI document: v.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
   DUMMY_BASE_URL,
   assertParamExists,
   setApiKeyToObject,
   setBasicAuthToObject,
   setBearerAuthToObject,
   setOAuthToObject,
   setSearchParams,
   serializeDataIfNeeded,
   toPathString,
   createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
   BASE_PATH,
   COLLECTION_FORMATS,
   BaseAPI,
   RequiredError,
   operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface AdditionalInfoRequest
 */
export interface AdditionalInfoRequest {
   /**
    *
    * @type {string}
    * @memberof AdditionalInfoRequest
    */
   officialEmail: string
   /**
    *
    * @type {string}
    * @memberof AdditionalInfoRequest
    */
   nickname: string
   /**
    *
    * @type {string}
    * @memberof AdditionalInfoRequest
    */
   jobGroup: string
   /**
    *
    * @type {string}
    * @memberof AdditionalInfoRequest
    */
   jobCategory: string
}
/**
 *
 * @export
 * @interface AnswerDetailResponse
 */
export interface AnswerDetailResponse {
   /**
    *
    * @type {number}
    * @memberof AnswerDetailResponse
    */
   answerId?: number
   /**
    *
    * @type {string}
    * @memberof AnswerDetailResponse
    */
   content?: string
   /**
    *
    * @type {boolean}
    * @memberof AnswerDetailResponse
    */
   isChosen?: boolean
   /**
    *
    * @type {boolean}
    * @memberof AnswerDetailResponse
    */
   isQuestioner?: boolean
   /**
    *
    * @type {MemberInfo}
    * @memberof AnswerDetailResponse
    */
   memberInfo?: MemberInfo
   /**
    *
    * @type {string}
    * @memberof AnswerDetailResponse
    */
   createdAt?: string
}
/**
 *
 * @export
 * @interface AnsweredQuestionPostsResponse
 */
export interface AnsweredQuestionPostsResponse {
   /**
    *
    * @type {number}
    * @memberof AnsweredQuestionPostsResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof AnsweredQuestionPostsResponse
    */
   questionTitle?: string
   /**
    *
    * @type {string}
    * @memberof AnsweredQuestionPostsResponse
    */
   questionContent?: string
   /**
    *
    * @type {string}
    * @memberof AnsweredQuestionPostsResponse
    */
   jobGroup?: string
   /**
    *
    * @type {number}
    * @memberof AnsweredQuestionPostsResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof AnsweredQuestionPostsResponse
    */
   questionPostCreatedAt?: string
   /**
    *
    * @type {boolean}
    * @memberof AnsweredQuestionPostsResponse
    */
   isChosen?: boolean
   /**
    *
    * @type {number}
    * @memberof AnsweredQuestionPostsResponse
    */
   bookmarkCount?: number
   /**
    *
    * @type {number}
    * @memberof AnsweredQuestionPostsResponse
    */
   recommendCount?: number
   /**
    *
    * @type {number}
    * @memberof AnsweredQuestionPostsResponse
    */
   answerId?: number
   /**
    *
    * @type {string}
    * @memberof AnsweredQuestionPostsResponse
    */
   answerContent?: string
   /**
    *
    * @type {string}
    * @memberof AnsweredQuestionPostsResponse
    */
   answerCreatedAt?: string
}
/**
 *
 * @export
 * @interface AuthCodeRequest
 */
export interface AuthCodeRequest {
   /**
    *
    * @type {string}
    * @memberof AuthCodeRequest
    */
   authCode: string
   /**
    *
    * @type {string}
    * @memberof AuthCodeRequest
    */
   targetEmail: string
}
/**
 *
 * @export
 * @interface AuthCodeResponse
 */
export interface AuthCodeResponse {
   /**
    *
    * @type {boolean}
    * @memberof AuthCodeResponse
    */
   result?: boolean
}
/**
 *
 * @export
 * @interface BookmarksResponse
 */
export interface BookmarksResponse {
   /**
    *
    * @type {number}
    * @memberof BookmarksResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof BookmarksResponse
    */
   questionTitle?: string
   /**
    *
    * @type {string}
    * @memberof BookmarksResponse
    */
   questionContent?: string
   /**
    *
    * @type {string}
    * @memberof BookmarksResponse
    */
   jobGroup?: string
   /**
    *
    * @type {number}
    * @memberof BookmarksResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof BookmarksResponse
    */
   createdAt?: string
   /**
    *
    * @type {boolean}
    * @memberof BookmarksResponse
    */
   isChosen?: boolean
   /**
    *
    * @type {number}
    * @memberof BookmarksResponse
    */
   bookmarkCount?: number
   /**
    *
    * @type {number}
    * @memberof BookmarksResponse
    */
   recommendCount?: number
}
/**
 *
 * @export
 * @interface CreditHistoryResponse
 */
export interface CreditHistoryResponse {
   /**
    *
    * @type {number}
    * @memberof CreditHistoryResponse
    */
   id?: number
   /**
    *
    * @type {string}
    * @memberof CreditHistoryResponse
    */
   type?: string
   /**
    *
    * @type {string}
    * @memberof CreditHistoryResponse
    */
   detail?: string
   /**
    *
    * @type {number}
    * @memberof CreditHistoryResponse
    */
   amount?: number
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
   /**
    *
    * @type {string}
    * @memberof ErrorResponse
    */
   message?: string
   /**
    *
    * @type {string}
    * @memberof ErrorResponse
    */
   code?: string
}
/**
 *
 * @export
 * @interface ImagesUploadRequest
 */
export interface ImagesUploadRequest {
   /**
    *
    * @type {Array<File>}
    * @memberof ImagesUploadRequest
    */
   imageFiles: Array<File>
}
/**
 *
 * @export
 * @interface ImagesUploadResponse
 */
export interface ImagesUploadResponse {
   /**
    *
    * @type {Array<string>}
    * @memberof ImagesUploadResponse
    */
   imageUrls?: Array<string>
}
/**
 *
 * @export
 * @interface InteractionResponse
 */
export interface InteractionResponse {
   /**
    *
    * @type {number}
    * @memberof InteractionResponse
    */
   count?: number
   /**
    *
    * @type {string}
    * @memberof InteractionResponse
    */
   interactionType?: string
}
/**
 *
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
   /**
    *
    * @type {boolean}
    * @memberof LogoutResponse
    */
   result?: boolean
}
/**
 *
 * @export
 * @interface MemberInfo
 */
export interface MemberInfo {
   /**
    *
    * @type {number}
    * @memberof MemberInfo
    */
   memberId?: number
   /**
    *
    * @type {string}
    * @memberof MemberInfo
    */
   nickname?: string
   /**
    *
    * @type {string}
    * @memberof MemberInfo
    */
   memberJobGroup?: string
   /**
    *
    * @type {number}
    * @memberof MemberInfo
    */
   profileImageNo?: number
}
/**
 *
 * @export
 * @interface MemberInformationResponse
 */
export interface MemberInformationResponse {
   /**
    *
    * @type {number}
    * @memberof MemberInformationResponse
    */
   memberId?: number
   /**
    *
    * @type {string}
    * @memberof MemberInformationResponse
    */
   nickname?: string
   /**
    *
    * @type {string}
    * @memberof MemberInformationResponse
    */
   socialName?: string
   /**
    *
    * @type {string}
    * @memberof MemberInformationResponse
    */
   officialEmail?: string
   /**
    *
    * @type {string}
    * @memberof MemberInformationResponse
    */
   socialEmail?: string
   /**
    *
    * @type {string}
    * @memberof MemberInformationResponse
    */
   jobGroup?: string
   /**
    *
    * @type {string}
    * @memberof MemberInformationResponse
    */
   jobCategory?: string
   /**
    *
    * @type {number}
    * @memberof MemberInformationResponse
    */
   credit?: number
   /**
    *
    * @type {number}
    * @memberof MemberInformationResponse
    */
   profileImageNo?: number
}
/**
 *
 * @export
 * @interface MemberProfileResponse
 */
export interface MemberProfileResponse {
   /**
    *
    * @type {number}
    * @memberof MemberProfileResponse
    */
   memberId?: number
   /**
    *
    * @type {string}
    * @memberof MemberProfileResponse
    */
   nickname?: string
   /**
    *
    * @type {string}
    * @memberof MemberProfileResponse
    */
   jobGroup?: string
   /**
    *
    * @type {string}
    * @memberof MemberProfileResponse
    */
   jobCategory?: string
   /**
    *
    * @type {number}
    * @memberof MemberProfileResponse
    */
   credit?: number
   /**
    *
    * @type {number}
    * @memberof MemberProfileResponse
    */
   profileImageNo?: number
}
/**
 *
 * @export
 * @interface PageResponseAnswerDetailResponse
 */
export interface PageResponseAnswerDetailResponse {
   /**
    *
    * @type {Array<AnswerDetailResponse>}
    * @memberof PageResponseAnswerDetailResponse
    */
   content?: Array<AnswerDetailResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseAnswerDetailResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseAnswerDetailResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface PageResponseAnsweredQuestionPostsResponse
 */
export interface PageResponseAnsweredQuestionPostsResponse {
   /**
    *
    * @type {Array<AnsweredQuestionPostsResponse>}
    * @memberof PageResponseAnsweredQuestionPostsResponse
    */
   content?: Array<AnsweredQuestionPostsResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseAnsweredQuestionPostsResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseAnsweredQuestionPostsResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface PageResponseBookmarksResponse
 */
export interface PageResponseBookmarksResponse {
   /**
    *
    * @type {Array<BookmarksResponse>}
    * @memberof PageResponseBookmarksResponse
    */
   content?: Array<BookmarksResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseBookmarksResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseBookmarksResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface PageResponseCreditHistoryResponse
 */
export interface PageResponseCreditHistoryResponse {
   /**
    *
    * @type {Array<CreditHistoryResponse>}
    * @memberof PageResponseCreditHistoryResponse
    */
   content?: Array<CreditHistoryResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseCreditHistoryResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseCreditHistoryResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface PageResponseQuestionPostSimpleResponse
 */
export interface PageResponseQuestionPostSimpleResponse {
   /**
    *
    * @type {Array<QuestionPostSimpleResponse>}
    * @memberof PageResponseQuestionPostSimpleResponse
    */
   content: Array<QuestionPostSimpleResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseQuestionPostSimpleResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseQuestionPostSimpleResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface PageResponseQuestionPostsResponse
 */
export interface PageResponseQuestionPostsResponse {
   /**
    *
    * @type {Array<QuestionPostsResponse>}
    * @memberof PageResponseQuestionPostsResponse
    */
   content?: Array<QuestionPostsResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseQuestionPostsResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseQuestionPostsResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface PageResponseRecQuestionPostResponse
 */
export interface PageResponseRecQuestionPostResponse {
   /**
    *
    * @type {Array<RecQuestionPostResponse>}
    * @memberof PageResponseRecQuestionPostResponse
    */
   content?: Array<RecQuestionPostResponse>
   /**
    *
    * @type {number}
    * @memberof PageResponseRecQuestionPostResponse
    */
   size?: number
   /**
    *
    * @type {boolean}
    * @memberof PageResponseRecQuestionPostResponse
    */
   hasNext?: boolean
}
/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
   /**
    *
    * @type {number}
    * @memberof Pageable
    */
   page?: number
   /**
    *
    * @type {number}
    * @memberof Pageable
    */
   size?: number
   /**
    *
    * @type {Array<string>}
    * @memberof Pageable
    */
   sort?: Array<string>
}
/**
 *
 * @export
 * @interface QuestionPostDetailResponse
 */
export interface QuestionPostDetailResponse {
   /**
    *
    * @type {number}
    * @memberof QuestionPostDetailResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostDetailResponse
    */
   title?: string
   /**
    *
    * @type {string}
    * @memberof QuestionPostDetailResponse
    */
   content?: string
   /**
    *
    * @type {Array<string>}
    * @memberof QuestionPostDetailResponse
    */
   imageUrls?: Array<string>
   /**
    *
    * @type {number}
    * @memberof QuestionPostDetailResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostDetailResponse
    */
   targetJobGroup?: string
   /**
    *
    * @type {MemberInfo}
    * @memberof QuestionPostDetailResponse
    */
   memberInfo?: MemberInfo
   /**
    *
    * @type {boolean}
    * @memberof QuestionPostDetailResponse
    */
   isSaved?: boolean
   /**
    *
    * @type {boolean}
    * @memberof QuestionPostDetailResponse
    */
   isRecommended?: boolean
   /**
    *
    * @type {number}
    * @memberof QuestionPostDetailResponse
    */
   savedCount?: number
   /**
    *
    * @type {number}
    * @memberof QuestionPostDetailResponse
    */
   recommendCount?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostDetailResponse
    */
   createdAt?: string
}
/**
 *
 * @export
 * @interface QuestionPostSearchCondition
 */
export interface QuestionPostSearchCondition {
   /**
    *
    * @type {string}
    * @memberof QuestionPostSearchCondition
    */
   keyword?: string
   /**
    *
    * @type {Array<string>}
    * @memberof QuestionPostSearchCondition
    */
   jobGroups?: Array<string>
   /**
    *
    * @type {boolean}
    * @memberof QuestionPostSearchCondition
    */
   isChosen?: boolean
}
/**
 *
 * @export
 * @interface QuestionPostSimpleResponse
 */
export interface QuestionPostSimpleResponse {
   /**
    *
    * @type {number}
    * @memberof QuestionPostSimpleResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostSimpleResponse
    */
   title?: string
   /**
    *
    * @type {string}
    * @memberof QuestionPostSimpleResponse
    */
   content?: string
   /**
    *
    * @type {string}
    * @memberof QuestionPostSimpleResponse
    */
   jobGroup?: string
   /**
    *
    * @type {number}
    * @memberof QuestionPostSimpleResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostSimpleResponse
    */
   createdAt?: string
   /**
    *
    * @type {boolean}
    * @memberof QuestionPostSimpleResponse
    */
   isChosen?: boolean
   /**
    *
    * @type {number}
    * @memberof QuestionPostSimpleResponse
    */
   savedCount?: number
   /**
    *
    * @type {number}
    * @memberof QuestionPostSimpleResponse
    */
   recommendCount?: number
}
/**
 *
 * @export
 * @interface QuestionPostsResponse
 */
export interface QuestionPostsResponse {
   /**
    *
    * @type {number}
    * @memberof QuestionPostsResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostsResponse
    */
   questionTitle?: string
   /**
    *
    * @type {string}
    * @memberof QuestionPostsResponse
    */
   questionContent?: string
   /**
    *
    * @type {string}
    * @memberof QuestionPostsResponse
    */
   jobGroup?: string
   /**
    *
    * @type {number}
    * @memberof QuestionPostsResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof QuestionPostsResponse
    */
   createdAt?: string
   /**
    *
    * @type {boolean}
    * @memberof QuestionPostsResponse
    */
   isChosen?: boolean
   /**
    *
    * @type {number}
    * @memberof QuestionPostsResponse
    */
   bookmarkCount?: number
   /**
    *
    * @type {number}
    * @memberof QuestionPostsResponse
    */
   recommendCount?: number
}
/**
 *
 * @export
 * @interface RecQuestionPostResponse
 */
export interface RecQuestionPostResponse {
   /**
    *
    * @type {number}
    * @memberof RecQuestionPostResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof RecQuestionPostResponse
    */
   title?: string
   /**
    *
    * @type {number}
    * @memberof RecQuestionPostResponse
    */
   reward?: number
   /**
    *
    * @type {boolean}
    * @memberof RecQuestionPostResponse
    */
   isChosen?: boolean
   /**
    *
    * @type {number}
    * @memberof RecQuestionPostResponse
    */
   savedCount?: number
   /**
    *
    * @type {number}
    * @memberof RecQuestionPostResponse
    */
   recommendCount?: number
}
/**
 *
 * @export
 * @interface RegisterAnswerRequest
 */
export interface RegisterAnswerRequest {
   /**
    *
    * @type {string}
    * @memberof RegisterAnswerRequest
    */
   content: string
}
/**
 *
 * @export
 * @interface RegisterQuestionPostRequest
 */
export interface RegisterQuestionPostRequest {
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostRequest
    */
   title?: string
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostRequest
    */
   content?: string
   /**
    *
    * @type {Array<string>}
    * @memberof RegisterQuestionPostRequest
    */
   imageUrls?: Array<string>
   /**
    *
    * @type {number}
    * @memberof RegisterQuestionPostRequest
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostRequest
    */
   targetJobGroup: string
}
/**
 *
 * @export
 * @interface RegisterQuestionPostResponse
 */
export interface RegisterQuestionPostResponse {
   /**
    *
    * @type {number}
    * @memberof RegisterQuestionPostResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostResponse
    */
   title?: string
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostResponse
    */
   content?: string
   /**
    *
    * @type {Array<string>}
    * @memberof RegisterQuestionPostResponse
    */
   imageUrls?: Array<string>
   /**
    *
    * @type {number}
    * @memberof RegisterQuestionPostResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostResponse
    */
   targetJobGroup?: string
   /**
    *
    * @type {MemberInfo}
    * @memberof RegisterQuestionPostResponse
    */
   memberInfo?: MemberInfo
   /**
    *
    * @type {string}
    * @memberof RegisterQuestionPostResponse
    */
   createdAt?: string
}
/**
 *
 * @export
 * @interface ReissueResponse
 */
export interface ReissueResponse {
   /**
    *
    * @type {boolean}
    * @memberof ReissueResponse
    */
   result?: boolean
}
/**
 *
 * @export
 * @interface SendMailRequest
 */
export interface SendMailRequest {
   /**
    *
    * @type {string}
    * @memberof SendMailRequest
    */
   targetEmail: string
}
/**
 *
 * @export
 * @interface SendMailResponse
 */
export interface SendMailResponse {
   /**
    *
    * @type {string}
    * @memberof SendMailResponse
    */
   targetEmail?: string
}
/**
 *
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
   /**
    *
    * @type {string}
    * @memberof SignUpResponse
    */
   nickName?: string
}
/**
 *
 * @export
 * @interface TempSignInRequest
 */
export interface TempSignInRequest {
   /**
    *
    * @type {string}
    * @memberof TempSignInRequest
    */
   socialEmail?: string
}
/**
 *
 * @export
 * @interface TempSignUpRequest
 */
export interface TempSignUpRequest {
   /**
    *
    * @type {string}
    * @memberof TempSignUpRequest
    */
   socialName?: string
   /**
    *
    * @type {string}
    * @memberof TempSignUpRequest
    */
   socialEmail?: string
}
/**
 *
 * @export
 * @interface UpdateMemberProfileRequest
 */
export interface UpdateMemberProfileRequest {
   /**
    *
    * @type {string}
    * @memberof UpdateMemberProfileRequest
    */
   nickname: string
   /**
    *
    * @type {string}
    * @memberof UpdateMemberProfileRequest
    */
   jobGroup: string
   /**
    *
    * @type {string}
    * @memberof UpdateMemberProfileRequest
    */
   jobCategory: string
}
/**
 *
 * @export
 * @interface UpdateQuestionPostRequest
 */
export interface UpdateQuestionPostRequest {
   /**
    *
    * @type {string}
    * @memberof UpdateQuestionPostRequest
    */
   title?: string
   /**
    *
    * @type {string}
    * @memberof UpdateQuestionPostRequest
    */
   content?: string
   /**
    *
    * @type {Array<string>}
    * @memberof UpdateQuestionPostRequest
    */
   imageUrls?: Array<string>
   /**
    *
    * @type {number}
    * @memberof UpdateQuestionPostRequest
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof UpdateQuestionPostRequest
    */
   targetJobGroup: string
}
/**
 *
 * @export
 * @interface UpdateQuestionPostResponse
 */
export interface UpdateQuestionPostResponse {
   /**
    *
    * @type {number}
    * @memberof UpdateQuestionPostResponse
    */
   questionPostId?: number
   /**
    *
    * @type {string}
    * @memberof UpdateQuestionPostResponse
    */
   title?: string
   /**
    *
    * @type {string}
    * @memberof UpdateQuestionPostResponse
    */
   content?: string
   /**
    *
    * @type {Array<string>}
    * @memberof UpdateQuestionPostResponse
    */
   imageUrls?: Array<string>
   /**
    *
    * @type {number}
    * @memberof UpdateQuestionPostResponse
    */
   reward?: number
   /**
    *
    * @type {string}
    * @memberof UpdateQuestionPostResponse
    */
   targetJobGroup?: string
}
/**
 *
 * @export
 * @interface ValidateNickNameRequest
 */
export interface ValidateNickNameRequest {
   /**
    *
    * @type {string}
    * @memberof ValidateNickNameRequest
    */
   nickname: string
}
/**
 *
 * @export
 * @interface ValidateNickNameResponse
 */
export interface ValidateNickNameResponse {
   /**
    *
    * @type {boolean}
    * @memberof ValidateNickNameResponse
    */
   isDuplicated?: boolean
}
/**
 *
 * @export
 * @interface VideoUploadRequest
 */
export interface VideoUploadRequest {
   /**
    *
    * @type {File}
    * @memberof VideoUploadRequest
    */
   videoFile: File
}
/**
 *
 * @export
 * @interface VideoUploadResponse
 */
export interface VideoUploadResponse {
   /**
    *
    * @type {string}
    * @memberof VideoUploadResponse
    */
   videoUrl?: string
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (
   configuration?: Configuration,
) {
   return {
      /**
       * 게시글을 추천하거나 북마크한다.
       * @summary 상호작용 등록 API
       * @param {number} questionPostId
       * @param {string} type
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      activateInteraction: async (
         questionPostId: number,
         type: string,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'questionPostId' is not null or undefined
         assertParamExists(
            'activateInteraction',
            'questionPostId',
            questionPostId,
         )
         // verify required parameter 'type' is not null or undefined
         assertParamExists('activateInteraction', 'type', type)
         const localVarPath =
            `/api/question-posts/{questionPostId}/activated`.replace(
               `{${'questionPostId'}}`,
               encodeURIComponent(String(questionPostId)),
            )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (type !== undefined) {
            localVarQueryParameter['type'] = type
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문자가 답변을 채택한다.
       * @summary 답변 채택 API
       * @param {number} answerId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAnswersByQuestionPostId: async (
         answerId: number,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'answerId' is not null or undefined
         assertParamExists('getAnswersByQuestionPostId', 'answerId', answerId)
         const localVarPath = `/api/question-posts/answers/{answerId}`.replace(
            `{${'answerId'}}`,
            encodeURIComponent(String(answerId)),
         )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문글에 속하는 답변을 모두 조회한다.
       * @summary 답변 조회 API
       * @param {number} questionPostId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAnswersByQuestionPostId1: async (
         questionPostId: number,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'questionPostId' is not null or undefined
         assertParamExists(
            'getAnswersByQuestionPostId1',
            'questionPostId',
            questionPostId,
         )
         const localVarPath =
            `/api/question-posts/{questionPostId}/answers`.replace(
               `{${'questionPostId'}}`,
               encodeURIComponent(String(questionPostId)),
            )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문글을 아이디로 상세조회한다.
       * @summary 질문글 상세 조회 API
       * @param {number} questionPostId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getQuestionPostById: async (
         questionPostId: number,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'questionPostId' is not null or undefined
         assertParamExists(
            'getQuestionPostById',
            'questionPostId',
            questionPostId,
         )
         const localVarPath = `/api/question-posts/{questionPostId}`.replace(
            `{${'questionPostId'}}`,
            encodeURIComponent(String(questionPostId)),
         )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 직군에 맞는 질문글을 추천순으로 조회한다.
       * @summary 질문글 추천 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getRecommendQuestionPosts: async (
         pageable: Pageable,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'pageable' is not null or undefined
         assertParamExists('getRecommendQuestionPosts', 'pageable', pageable)
         const localVarPath = `/api/question-posts/recommends`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (pageable !== undefined) {
            for (const [key, value] of Object.entries(pageable)) {
               localVarQueryParameter[key] = value
            }
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 게시글을 추천하거나 북마크 취소한다.
       * @summary 상호작용 등록 API
       * @param {number} questionPostId
       * @param {string} type
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      inactivateInteraction: async (
         questionPostId: number,
         type: string,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'questionPostId' is not null or undefined
         assertParamExists(
            'inactivateInteraction',
            'questionPostId',
            questionPostId,
         )
         // verify required parameter 'type' is not null or undefined
         assertParamExists('inactivateInteraction', 'type', type)
         const localVarPath =
            `/api/question-posts/{questionPostId}/inactivated`.replace(
               `{${'questionPostId'}}`,
               encodeURIComponent(String(questionPostId)),
            )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (type !== undefined) {
            localVarQueryParameter['type'] = type
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문글에 대한 답변을 작성한다.
       * @summary 답변 등록 API
       * @param {number} questionPostId
       * @param {RegisterAnswerRequest} registerAnswerRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      registerAnswer: async (
         questionPostId: number,
         registerAnswerRequest: RegisterAnswerRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'questionPostId' is not null or undefined
         assertParamExists('registerAnswer', 'questionPostId', questionPostId)
         // verify required parameter 'registerAnswerRequest' is not null or undefined
         assertParamExists(
            'registerAnswer',
            'registerAnswerRequest',
            registerAnswerRequest,
         )
         const localVarPath =
            `/api/question-posts/{questionPostId}/answers`.replace(
               `{${'questionPostId'}}`,
               encodeURIComponent(String(questionPostId)),
            )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            registerAnswerRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문글을 등록한다
       * @summary 질문글 등록 API
       * @param {RegisterQuestionPostRequest} registerQuestionPostRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      registerQuestionPost: async (
         registerQuestionPostRequest: RegisterQuestionPostRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'registerQuestionPostRequest' is not null or undefined
         assertParamExists(
            'registerQuestionPost',
            'registerQuestionPostRequest',
            registerQuestionPostRequest,
         )
         const localVarPath = `/api/question-posts`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            registerQuestionPostRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문글을 키워드로 검색하고 정렬, 필터링을 한다.
       * @summary 질문글 검색 API
       * @param {QuestionPostSearchCondition} condition
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      searchQuestionPost: async (
         condition: QuestionPostSearchCondition,
         pageable: Pageable,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'condition' is not null or undefined
         assertParamExists('searchQuestionPost', 'condition', condition)
         // verify required parameter 'pageable' is not null or undefined
         assertParamExists('searchQuestionPost', 'pageable', pageable)
         const localVarPath = `/api/question-posts/search`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (condition !== undefined) {
            for (const [key, value] of Object.entries(condition)) {
               localVarQueryParameter[key] = value
            }
         }

         if (pageable !== undefined) {
            for (const [key, value] of Object.entries(pageable)) {
               localVarQueryParameter[key] = value
            }
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 질문자가 질문글을 수정한다.
       * @summary 질문글 수정 API
       * @param {number} questionPostId
       * @param {UpdateQuestionPostRequest} updateQuestionPostRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateQuestionPosts: async (
         questionPostId: number,
         updateQuestionPostRequest: UpdateQuestionPostRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'questionPostId' is not null or undefined
         assertParamExists(
            'updateQuestionPosts',
            'questionPostId',
            questionPostId,
         )
         // verify required parameter 'updateQuestionPostRequest' is not null or undefined
         assertParamExists(
            'updateQuestionPosts',
            'updateQuestionPostRequest',
            updateQuestionPostRequest,
         )
         const localVarPath =
            `/api/question-posts/{questionPostId}/edit`.replace(
               `{${'questionPostId'}}`,
               encodeURIComponent(String(questionPostId)),
            )
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'PATCH',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            updateQuestionPostRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
   }
}

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function (configuration?: Configuration) {
   const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
   return {
      /**
       * 게시글을 추천하거나 북마크한다.
       * @summary 상호작용 등록 API
       * @param {number} questionPostId
       * @param {string} type
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async activateInteraction(
         questionPostId: number,
         type: string,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<InteractionResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.activateInteraction(
               questionPostId,
               type,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.activateInteraction']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문자가 답변을 채택한다.
       * @summary 답변 채택 API
       * @param {number} answerId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getAnswersByQuestionPostId(
         answerId: number,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<AnswerDetailResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getAnswersByQuestionPostId(
               answerId,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.getAnswersByQuestionPostId']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문글에 속하는 답변을 모두 조회한다.
       * @summary 답변 조회 API
       * @param {number} questionPostId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getAnswersByQuestionPostId1(
         questionPostId: number,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseAnswerDetailResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getAnswersByQuestionPostId1(
               questionPostId,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.getAnswersByQuestionPostId1']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문글을 아이디로 상세조회한다.
       * @summary 질문글 상세 조회 API
       * @param {number} questionPostId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getQuestionPostById(
         questionPostId: number,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<QuestionPostDetailResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getQuestionPostById(
               questionPostId,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.getQuestionPostById']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 직군에 맞는 질문글을 추천순으로 조회한다.
       * @summary 질문글 추천 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getRecommendQuestionPosts(
         pageable: Pageable,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseRecQuestionPostResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getRecommendQuestionPosts(
               pageable,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.getRecommendQuestionPosts']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 게시글을 추천하거나 북마크 취소한다.
       * @summary 상호작용 등록 API
       * @param {number} questionPostId
       * @param {string} type
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async inactivateInteraction(
         questionPostId: number,
         type: string,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<InteractionResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.inactivateInteraction(
               questionPostId,
               type,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.inactivateInteraction']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문글에 대한 답변을 작성한다.
       * @summary 답변 등록 API
       * @param {number} questionPostId
       * @param {RegisterAnswerRequest} registerAnswerRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async registerAnswer(
         questionPostId: number,
         registerAnswerRequest: RegisterAnswerRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<AnswerDetailResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.registerAnswer(
               questionPostId,
               registerAnswerRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.registerAnswer']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문글을 등록한다
       * @summary 질문글 등록 API
       * @param {RegisterQuestionPostRequest} registerQuestionPostRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async registerQuestionPost(
         registerQuestionPostRequest: RegisterQuestionPostRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<RegisterQuestionPostResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.registerQuestionPost(
               registerQuestionPostRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.registerQuestionPost']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문글을 키워드로 검색하고 정렬, 필터링을 한다.
       * @summary 질문글 검색 API
       * @param {QuestionPostSearchCondition} condition
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async searchQuestionPost(
         condition: QuestionPostSearchCondition,
         pageable: Pageable,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseQuestionPostSimpleResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.searchQuestionPost(
               condition,
               pageable,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.searchQuestionPost']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 질문자가 질문글을 수정한다.
       * @summary 질문글 수정 API
       * @param {number} questionPostId
       * @param {UpdateQuestionPostRequest} updateQuestionPostRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updateQuestionPosts(
         questionPostId: number,
         updateQuestionPostRequest: UpdateQuestionPostRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<UpdateQuestionPostResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.updateQuestionPosts(
               questionPostId,
               updateQuestionPostRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['APIApi.updateQuestionPosts']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
   }
}

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (
   configuration?: Configuration,
   basePath?: string,
   axios?: AxiosInstance,
) {
   const localVarFp = APIApiFp(configuration)
   return {
      /**
       * 게시글을 추천하거나 북마크한다.
       * @summary 상호작용 등록 API
       * @param {number} questionPostId
       * @param {string} type
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      activateInteraction(
         questionPostId: number,
         type: string,
         options?: any,
      ): AxiosPromise<InteractionResponse> {
         return localVarFp
            .activateInteraction(questionPostId, type, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문자가 답변을 채택한다.
       * @summary 답변 채택 API
       * @param {number} answerId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAnswersByQuestionPostId(
         answerId: number,
         options?: any,
      ): AxiosPromise<AnswerDetailResponse> {
         return localVarFp
            .getAnswersByQuestionPostId(answerId, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문글에 속하는 답변을 모두 조회한다.
       * @summary 답변 조회 API
       * @param {number} questionPostId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAnswersByQuestionPostId1(
         questionPostId: number,
         options?: any,
      ): AxiosPromise<PageResponseAnswerDetailResponse> {
         return localVarFp
            .getAnswersByQuestionPostId1(questionPostId, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문글을 아이디로 상세조회한다.
       * @summary 질문글 상세 조회 API
       * @param {number} questionPostId
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getQuestionPostById(
         questionPostId: number,
         options?: any,
      ): AxiosPromise<QuestionPostDetailResponse> {
         return localVarFp
            .getQuestionPostById(questionPostId, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 직군에 맞는 질문글을 추천순으로 조회한다.
       * @summary 질문글 추천 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getRecommendQuestionPosts(
         pageable: Pageable,
         options?: any,
      ): AxiosPromise<PageResponseRecQuestionPostResponse> {
         return localVarFp
            .getRecommendQuestionPosts(pageable, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 게시글을 추천하거나 북마크 취소한다.
       * @summary 상호작용 등록 API
       * @param {number} questionPostId
       * @param {string} type
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      inactivateInteraction(
         questionPostId: number,
         type: string,
         options?: any,
      ): AxiosPromise<InteractionResponse> {
         return localVarFp
            .inactivateInteraction(questionPostId, type, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문글에 대한 답변을 작성한다.
       * @summary 답변 등록 API
       * @param {number} questionPostId
       * @param {RegisterAnswerRequest} registerAnswerRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      registerAnswer(
         questionPostId: number,
         registerAnswerRequest: RegisterAnswerRequest,
         options?: any,
      ): AxiosPromise<AnswerDetailResponse> {
         return localVarFp
            .registerAnswer(questionPostId, registerAnswerRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문글을 등록한다
       * @summary 질문글 등록 API
       * @param {RegisterQuestionPostRequest} registerQuestionPostRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      registerQuestionPost(
         registerQuestionPostRequest: RegisterQuestionPostRequest,
         options?: any,
      ): AxiosPromise<RegisterQuestionPostResponse> {
         return localVarFp
            .registerQuestionPost(registerQuestionPostRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문글을 키워드로 검색하고 정렬, 필터링을 한다.
       * @summary 질문글 검색 API
       * @param {QuestionPostSearchCondition} condition
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      searchQuestionPost(
         condition: QuestionPostSearchCondition,
         pageable: Pageable,
         options?: any,
      ): AxiosPromise<PageResponseQuestionPostSimpleResponse> {
         return localVarFp
            .searchQuestionPost(condition, pageable, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 질문자가 질문글을 수정한다.
       * @summary 질문글 수정 API
       * @param {number} questionPostId
       * @param {UpdateQuestionPostRequest} updateQuestionPostRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateQuestionPosts(
         questionPostId: number,
         updateQuestionPostRequest: UpdateQuestionPostRequest,
         options?: any,
      ): AxiosPromise<UpdateQuestionPostResponse> {
         return localVarFp
            .updateQuestionPosts(
               questionPostId,
               updateQuestionPostRequest,
               options,
            )
            .then((request) => request(axios, basePath))
      },
   }
}

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
   /**
    * 게시글을 추천하거나 북마크한다.
    * @summary 상호작용 등록 API
    * @param {number} questionPostId
    * @param {string} type
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public activateInteraction(
      questionPostId: number,
      type: string,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .activateInteraction(questionPostId, type, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문자가 답변을 채택한다.
    * @summary 답변 채택 API
    * @param {number} answerId
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public getAnswersByQuestionPostId(
      answerId: number,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .getAnswersByQuestionPostId(answerId, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문글에 속하는 답변을 모두 조회한다.
    * @summary 답변 조회 API
    * @param {number} questionPostId
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public getAnswersByQuestionPostId1(
      questionPostId: number,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .getAnswersByQuestionPostId1(questionPostId, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문글을 아이디로 상세조회한다.
    * @summary 질문글 상세 조회 API
    * @param {number} questionPostId
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public getQuestionPostById(
      questionPostId: number,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .getQuestionPostById(questionPostId, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 직군에 맞는 질문글을 추천순으로 조회한다.
    * @summary 질문글 추천 API
    * @param {Pageable} pageable
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public getRecommendQuestionPosts(
      pageable: Pageable,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .getRecommendQuestionPosts(pageable, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 게시글을 추천하거나 북마크 취소한다.
    * @summary 상호작용 등록 API
    * @param {number} questionPostId
    * @param {string} type
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public inactivateInteraction(
      questionPostId: number,
      type: string,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .inactivateInteraction(questionPostId, type, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문글에 대한 답변을 작성한다.
    * @summary 답변 등록 API
    * @param {number} questionPostId
    * @param {RegisterAnswerRequest} registerAnswerRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public registerAnswer(
      questionPostId: number,
      registerAnswerRequest: RegisterAnswerRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .registerAnswer(questionPostId, registerAnswerRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문글을 등록한다
    * @summary 질문글 등록 API
    * @param {RegisterQuestionPostRequest} registerQuestionPostRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public registerQuestionPost(
      registerQuestionPostRequest: RegisterQuestionPostRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .registerQuestionPost(registerQuestionPostRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문글을 키워드로 검색하고 정렬, 필터링을 한다.
    * @summary 질문글 검색 API
    * @param {QuestionPostSearchCondition} condition
    * @param {Pageable} pageable
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public searchQuestionPost(
      condition: QuestionPostSearchCondition,
      pageable: Pageable,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .searchQuestionPost(condition, pageable, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 질문자가 질문글을 수정한다.
    * @summary 질문글 수정 API
    * @param {number} questionPostId
    * @param {UpdateQuestionPostRequest} updateQuestionPostRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof APIApi
    */
   public updateQuestionPosts(
      questionPostId: number,
      updateQuestionPostRequest: UpdateQuestionPostRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return APIApiFp(this.configuration)
         .updateQuestionPosts(
            questionPostId,
            updateQuestionPostRequest,
            options,
         )
         .then((request) => request(this.axios, this.basePath))
   }
}

/**
 * MailAPIApi - axios parameter creator
 * @export
 */
export const MailAPIApiAxiosParamCreator = function (
   configuration?: Configuration,
) {
   return {
      /**
       * 요청 받은 이메일 중복 가입 여부를 검증하고, 해당 이메일로 인증 코드 이메일 발송한다.
       * @summary 공무원 이메일 인증 코드 요청 API
       * @param {SendMailRequest} sendMailRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      sendAuthCodeToMail: async (
         sendMailRequest: SendMailRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'sendMailRequest' is not null or undefined
         assertParamExists(
            'sendAuthCodeToMail',
            'sendMailRequest',
            sendMailRequest,
         )
         const localVarPath = `/api/auth/check-email`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            sendMailRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 인증 코드의 일치 여부를 검증한다.
       * @summary 공무원 이메일 인증 코드 검증 API
       * @param {AuthCodeRequest} authCodeRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      verifyMailAuthCode: async (
         authCodeRequest: AuthCodeRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'authCodeRequest' is not null or undefined
         assertParamExists(
            'verifyMailAuthCode',
            'authCodeRequest',
            authCodeRequest,
         )
         const localVarPath = `/api/auth/check-email/authCode`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            authCodeRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
   }
}

/**
 * MailAPIApi - functional programming interface
 * @export
 */
export const MailAPIApiFp = function (configuration?: Configuration) {
   const localVarAxiosParamCreator = MailAPIApiAxiosParamCreator(configuration)
   return {
      /**
       * 요청 받은 이메일 중복 가입 여부를 검증하고, 해당 이메일로 인증 코드 이메일 발송한다.
       * @summary 공무원 이메일 인증 코드 요청 API
       * @param {SendMailRequest} sendMailRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async sendAuthCodeToMail(
         sendMailRequest: SendMailRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<SendMailResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.sendAuthCodeToMail(
               sendMailRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MailAPIApi.sendAuthCodeToMail']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 인증 코드의 일치 여부를 검증한다.
       * @summary 공무원 이메일 인증 코드 검증 API
       * @param {AuthCodeRequest} authCodeRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async verifyMailAuthCode(
         authCodeRequest: AuthCodeRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<AuthCodeResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.verifyMailAuthCode(
               authCodeRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MailAPIApi.verifyMailAuthCode']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
   }
}

/**
 * MailAPIApi - factory interface
 * @export
 */
export const MailAPIApiFactory = function (
   configuration?: Configuration,
   basePath?: string,
   axios?: AxiosInstance,
) {
   const localVarFp = MailAPIApiFp(configuration)
   return {
      /**
       * 요청 받은 이메일 중복 가입 여부를 검증하고, 해당 이메일로 인증 코드 이메일 발송한다.
       * @summary 공무원 이메일 인증 코드 요청 API
       * @param {SendMailRequest} sendMailRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      sendAuthCodeToMail(
         sendMailRequest: SendMailRequest,
         options?: any,
      ): AxiosPromise<SendMailResponse> {
         return localVarFp
            .sendAuthCodeToMail(sendMailRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 인증 코드의 일치 여부를 검증한다.
       * @summary 공무원 이메일 인증 코드 검증 API
       * @param {AuthCodeRequest} authCodeRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      verifyMailAuthCode(
         authCodeRequest: AuthCodeRequest,
         options?: any,
      ): AxiosPromise<AuthCodeResponse> {
         return localVarFp
            .verifyMailAuthCode(authCodeRequest, options)
            .then((request) => request(axios, basePath))
      },
   }
}

/**
 * MailAPIApi - object-oriented interface
 * @export
 * @class MailAPIApi
 * @extends {BaseAPI}
 */
export class MailAPIApi extends BaseAPI {
   /**
    * 요청 받은 이메일 중복 가입 여부를 검증하고, 해당 이메일로 인증 코드 이메일 발송한다.
    * @summary 공무원 이메일 인증 코드 요청 API
    * @param {SendMailRequest} sendMailRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MailAPIApi
    */
   public sendAuthCodeToMail(
      sendMailRequest: SendMailRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return MailAPIApiFp(this.configuration)
         .sendAuthCodeToMail(sendMailRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 인증 코드의 일치 여부를 검증한다.
    * @summary 공무원 이메일 인증 코드 검증 API
    * @param {AuthCodeRequest} authCodeRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MailAPIApi
    */
   public verifyMailAuthCode(
      authCodeRequest: AuthCodeRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return MailAPIApiFp(this.configuration)
         .verifyMailAuthCode(authCodeRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }
}

/**
 * MemberAPIApi - axios parameter creator
 * @export
 */
export const MemberAPIApiAxiosParamCreator = function (
   configuration?: Configuration,
) {
   return {
      /**
       * 댓글 단 질문을 전체 조회한다.
       * @summary 댓글 단 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAnsweredQuestionPostsByMember: async (
         pageable: Pageable,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'pageable' is not null or undefined
         assertParamExists(
            'getAnsweredQuestionPostsByMember',
            'pageable',
            pageable,
         )
         const localVarPath = `/api/members/question-posts/answers`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (pageable !== undefined) {
            for (const [key, value] of Object.entries(pageable)) {
               localVarQueryParameter[key] = value
            }
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 스크랩한 질문을 전체 조회한다.
       * @summary 스크랩 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getBookmarksByMember: async (
         pageable: Pageable,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'pageable' is not null or undefined
         assertParamExists('getBookmarksByMember', 'pageable', pageable)
         const localVarPath = `/api/members/question-posts/bookmarks`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (pageable !== undefined) {
            for (const [key, value] of Object.entries(pageable)) {
               localVarQueryParameter[key] = value
            }
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 타입에 맞는 크레딧 목록을 전체 조회한다.
       * @summary 크레딧 목록 전체 조회 API
       * @param {string} type
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getCreditHistoryByMember: async (
         type: string,
         pageable: Pageable,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'type' is not null or undefined
         assertParamExists('getCreditHistoryByMember', 'type', type)
         // verify required parameter 'pageable' is not null or undefined
         assertParamExists('getCreditHistoryByMember', 'pageable', pageable)
         const localVarPath = `/api/members/credit/histories`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (type !== undefined) {
            localVarQueryParameter['type'] = type
         }

         if (pageable !== undefined) {
            for (const [key, value] of Object.entries(pageable)) {
               localVarQueryParameter[key] = value
            }
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 회원 정보를 전체 조회한다.
       * @summary 회원 정보 전체 조회 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getMemberInformation: async (
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         const localVarPath = `/api/members/information`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 로그인 된 사용자 프로필 정보를 조회한다.
       * @summary 프로필 조회 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getMemberProfile: async (
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         const localVarPath = `/api/members/profile`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 작성한 질문을 전체 조회한다.
       * @summary 작성한 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getQuestionPostsByMember: async (
         pageable: Pageable,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'pageable' is not null or undefined
         assertParamExists('getQuestionPostsByMember', 'pageable', pageable)
         const localVarPath = `/api/members/question-posts`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'GET',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         if (pageable !== undefined) {
            for (const [key, value] of Object.entries(pageable)) {
               localVarQueryParameter[key] = value
            }
         }

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 로그인 된 사용자 프로필 정보를 수정한다.
       * @summary 프로필 수정 API
       * @param {UpdateMemberProfileRequest} updateMemberProfileRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateMemberProfile: async (
         updateMemberProfileRequest: UpdateMemberProfileRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'updateMemberProfileRequest' is not null or undefined
         assertParamExists(
            'updateMemberProfile',
            'updateMemberProfileRequest',
            updateMemberProfileRequest,
         )
         const localVarPath = `/api/members/profile/edit`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'PATCH',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            updateMemberProfileRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
   }
}

/**
 * MemberAPIApi - functional programming interface
 * @export
 */
export const MemberAPIApiFp = function (configuration?: Configuration) {
   const localVarAxiosParamCreator =
      MemberAPIApiAxiosParamCreator(configuration)
   return {
      /**
       * 댓글 단 질문을 전체 조회한다.
       * @summary 댓글 단 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getAnsweredQuestionPostsByMember(
         pageable: Pageable,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseAnsweredQuestionPostsResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getAnsweredQuestionPostsByMember(
               pageable,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap[
               'MemberAPIApi.getAnsweredQuestionPostsByMember'
            ]?.[localVarOperationServerIndex]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 스크랩한 질문을 전체 조회한다.
       * @summary 스크랩 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getBookmarksByMember(
         pageable: Pageable,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseBookmarksResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getBookmarksByMember(
               pageable,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MemberAPIApi.getBookmarksByMember']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 타입에 맞는 크레딧 목록을 전체 조회한다.
       * @summary 크레딧 목록 전체 조회 API
       * @param {string} type
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getCreditHistoryByMember(
         type: string,
         pageable: Pageable,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseCreditHistoryResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getCreditHistoryByMember(
               type,
               pageable,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MemberAPIApi.getCreditHistoryByMember']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 회원 정보를 전체 조회한다.
       * @summary 회원 정보 전체 조회 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getMemberInformation(
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<MemberInformationResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getMemberInformation(options)
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MemberAPIApi.getMemberInformation']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 로그인 된 사용자 프로필 정보를 조회한다.
       * @summary 프로필 조회 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getMemberProfile(
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<MemberProfileResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getMemberProfile(options)
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MemberAPIApi.getMemberProfile']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 작성한 질문을 전체 조회한다.
       * @summary 작성한 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getQuestionPostsByMember(
         pageable: Pageable,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<PageResponseQuestionPostsResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.getQuestionPostsByMember(
               pageable,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MemberAPIApi.getQuestionPostsByMember']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 로그인 된 사용자 프로필 정보를 수정한다.
       * @summary 프로필 수정 API
       * @param {UpdateMemberProfileRequest} updateMemberProfileRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updateMemberProfile(
         updateMemberProfileRequest: UpdateMemberProfileRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<MemberProfileResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.updateMemberProfile(
               updateMemberProfileRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['MemberAPIApi.updateMemberProfile']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
   }
}

/**
 * MemberAPIApi - factory interface
 * @export
 */
export const MemberAPIApiFactory = function (
   configuration?: Configuration,
   basePath?: string,
   axios?: AxiosInstance,
) {
   const localVarFp = MemberAPIApiFp(configuration)
   return {
      /**
       * 댓글 단 질문을 전체 조회한다.
       * @summary 댓글 단 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAnsweredQuestionPostsByMember(
         pageable: Pageable,
         options?: any,
      ): AxiosPromise<PageResponseAnsweredQuestionPostsResponse> {
         return localVarFp
            .getAnsweredQuestionPostsByMember(pageable, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 스크랩한 질문을 전체 조회한다.
       * @summary 스크랩 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getBookmarksByMember(
         pageable: Pageable,
         options?: any,
      ): AxiosPromise<PageResponseBookmarksResponse> {
         return localVarFp
            .getBookmarksByMember(pageable, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 타입에 맞는 크레딧 목록을 전체 조회한다.
       * @summary 크레딧 목록 전체 조회 API
       * @param {string} type
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getCreditHistoryByMember(
         type: string,
         pageable: Pageable,
         options?: any,
      ): AxiosPromise<PageResponseCreditHistoryResponse> {
         return localVarFp
            .getCreditHistoryByMember(type, pageable, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 회원 정보를 전체 조회한다.
       * @summary 회원 정보 전체 조회 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getMemberInformation(
         options?: any,
      ): AxiosPromise<MemberInformationResponse> {
         return localVarFp
            .getMemberInformation(options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 로그인 된 사용자 프로필 정보를 조회한다.
       * @summary 프로필 조회 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getMemberProfile(options?: any): AxiosPromise<MemberProfileResponse> {
         return localVarFp
            .getMemberProfile(options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 작성한 질문을 전체 조회한다.
       * @summary 작성한 질문 전체 조회 API
       * @param {Pageable} pageable
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getQuestionPostsByMember(
         pageable: Pageable,
         options?: any,
      ): AxiosPromise<PageResponseQuestionPostsResponse> {
         return localVarFp
            .getQuestionPostsByMember(pageable, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 로그인 된 사용자 프로필 정보를 수정한다.
       * @summary 프로필 수정 API
       * @param {UpdateMemberProfileRequest} updateMemberProfileRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateMemberProfile(
         updateMemberProfileRequest: UpdateMemberProfileRequest,
         options?: any,
      ): AxiosPromise<MemberProfileResponse> {
         return localVarFp
            .updateMemberProfile(updateMemberProfileRequest, options)
            .then((request) => request(axios, basePath))
      },
   }
}

/**
 * MemberAPIApi - object-oriented interface
 * @export
 * @class MemberAPIApi
 * @extends {BaseAPI}
 */
export class MemberAPIApi extends BaseAPI {
   /**
    * 댓글 단 질문을 전체 조회한다.
    * @summary 댓글 단 질문 전체 조회 API
    * @param {Pageable} pageable
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public getAnsweredQuestionPostsByMember(
      pageable: Pageable,
      options?: RawAxiosRequestConfig,
   ) {
      return MemberAPIApiFp(this.configuration)
         .getAnsweredQuestionPostsByMember(pageable, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 스크랩한 질문을 전체 조회한다.
    * @summary 스크랩 질문 전체 조회 API
    * @param {Pageable} pageable
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public getBookmarksByMember(
      pageable: Pageable,
      options?: RawAxiosRequestConfig,
   ) {
      return MemberAPIApiFp(this.configuration)
         .getBookmarksByMember(pageable, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 타입에 맞는 크레딧 목록을 전체 조회한다.
    * @summary 크레딧 목록 전체 조회 API
    * @param {string} type
    * @param {Pageable} pageable
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public getCreditHistoryByMember(
      type: string,
      pageable: Pageable,
      options?: RawAxiosRequestConfig,
   ) {
      return MemberAPIApiFp(this.configuration)
         .getCreditHistoryByMember(type, pageable, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 회원 정보를 전체 조회한다.
    * @summary 회원 정보 전체 조회 API
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public getMemberInformation(options?: RawAxiosRequestConfig) {
      return MemberAPIApiFp(this.configuration)
         .getMemberInformation(options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 로그인 된 사용자 프로필 정보를 조회한다.
    * @summary 프로필 조회 API
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public getMemberProfile(options?: RawAxiosRequestConfig) {
      return MemberAPIApiFp(this.configuration)
         .getMemberProfile(options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 작성한 질문을 전체 조회한다.
    * @summary 작성한 질문 전체 조회 API
    * @param {Pageable} pageable
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public getQuestionPostsByMember(
      pageable: Pageable,
      options?: RawAxiosRequestConfig,
   ) {
      return MemberAPIApiFp(this.configuration)
         .getQuestionPostsByMember(pageable, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 로그인 된 사용자 프로필 정보를 수정한다.
    * @summary 프로필 수정 API
    * @param {UpdateMemberProfileRequest} updateMemberProfileRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof MemberAPIApi
    */
   public updateMemberProfile(
      updateMemberProfileRequest: UpdateMemberProfileRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return MemberAPIApiFp(this.configuration)
         .updateMemberProfile(updateMemberProfileRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }
}

/**
 * S3APIApi - axios parameter creator
 * @export
 */
export const S3APIApiAxiosParamCreator = function (
   configuration?: Configuration,
) {
   return {
      /**
       * 1~10장의 이미지를 등록한다.
       * @summary 이미지 등록 API
       * @param {ImagesUploadRequest} [imagesUploadRequest]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      uploadImages: async (
         imagesUploadRequest?: ImagesUploadRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         const localVarPath = `/api/files/images`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            imagesUploadRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 최대 45MB의 동영상을 등록한다.
       * @summary 동영상 등록 API
       * @param {VideoUploadRequest} [videoUploadRequest]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      uploadVideo: async (
         videoUploadRequest?: VideoUploadRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         const localVarPath = `/api/files/videos`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            videoUploadRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
   }
}

/**
 * S3APIApi - functional programming interface
 * @export
 */
export const S3APIApiFp = function (configuration?: Configuration) {
   const localVarAxiosParamCreator = S3APIApiAxiosParamCreator(configuration)
   return {
      /**
       * 1~10장의 이미지를 등록한다.
       * @summary 이미지 등록 API
       * @param {ImagesUploadRequest} [imagesUploadRequest]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async uploadImages(
         imagesUploadRequest?: ImagesUploadRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<ImagesUploadResponse>
      > {
         const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImages(
            imagesUploadRequest,
            options,
         )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['S3APIApi.uploadImages']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 최대 45MB의 동영상을 등록한다.
       * @summary 동영상 등록 API
       * @param {VideoUploadRequest} [videoUploadRequest]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async uploadVideo(
         videoUploadRequest?: VideoUploadRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<VideoUploadResponse>
      > {
         const localVarAxiosArgs = await localVarAxiosParamCreator.uploadVideo(
            videoUploadRequest,
            options,
         )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['S3APIApi.uploadVideo']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
   }
}

/**
 * S3APIApi - factory interface
 * @export
 */
export const S3APIApiFactory = function (
   configuration?: Configuration,
   basePath?: string,
   axios?: AxiosInstance,
) {
   const localVarFp = S3APIApiFp(configuration)
   return {
      /**
       * 1~10장의 이미지를 등록한다.
       * @summary 이미지 등록 API
       * @param {ImagesUploadRequest} [imagesUploadRequest]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      uploadImages(
         imagesUploadRequest?: ImagesUploadRequest,
         options?: any,
      ): AxiosPromise<ImagesUploadResponse> {
         return localVarFp
            .uploadImages(imagesUploadRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 최대 45MB의 동영상을 등록한다.
       * @summary 동영상 등록 API
       * @param {VideoUploadRequest} [videoUploadRequest]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      uploadVideo(
         videoUploadRequest?: VideoUploadRequest,
         options?: any,
      ): AxiosPromise<VideoUploadResponse> {
         return localVarFp
            .uploadVideo(videoUploadRequest, options)
            .then((request) => request(axios, basePath))
      },
   }
}

/**
 * S3APIApi - object-oriented interface
 * @export
 * @class S3APIApi
 * @extends {BaseAPI}
 */
export class S3APIApi extends BaseAPI {
   /**
    * 1~10장의 이미지를 등록한다.
    * @summary 이미지 등록 API
    * @param {ImagesUploadRequest} [imagesUploadRequest]
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof S3APIApi
    */
   public uploadImages(
      imagesUploadRequest?: ImagesUploadRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return S3APIApiFp(this.configuration)
         .uploadImages(imagesUploadRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 최대 45MB의 동영상을 등록한다.
    * @summary 동영상 등록 API
    * @param {VideoUploadRequest} [videoUploadRequest]
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof S3APIApi
    */
   public uploadVideo(
      videoUploadRequest?: VideoUploadRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return S3APIApiFp(this.configuration)
         .uploadVideo(videoUploadRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }
}

/**
 * SocialLoginAPIApi - axios parameter creator
 * @export
 */
export const SocialLoginAPIApiAxiosParamCreator = function (
   configuration?: Configuration,
) {
   return {
      /**
       * 닉네임 중복을 검증한다.
       * @summary 닉네임 중복 검증 API
       * @param {ValidateNickNameRequest} validateNickNameRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      checkNickName: async (
         validateNickNameRequest: ValidateNickNameRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'validateNickNameRequest' is not null or undefined
         assertParamExists(
            'checkNickName',
            'validateNickNameRequest',
            validateNickNameRequest,
         )
         const localVarPath = `/api/auth/check-nickname`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            validateNickNameRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 로그아웃한다.
       * @summary 로그아웃 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      logout: async (
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         const localVarPath = `/api/auth/logout`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 토큰을 재발급한다.
       * @summary 토큰 재발급 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      reissue: async (
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         const localVarPath = `/api/auth/reissue/token`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 추가 정보를 저장한다.
       * @summary 추가정보 API
       * @param {AdditionalInfoRequest} additionalInfoRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      signUp: async (
         additionalInfoRequest: AdditionalInfoRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'additionalInfoRequest' is not null or undefined
         assertParamExists(
            'signUp',
            'additionalInfoRequest',
            additionalInfoRequest,
         )
         const localVarPath = `/api/auth/member`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            additionalInfoRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 임시 로그인 후 토큰을 발급한다.
       * @summary 임시 로그인(토큰 발급) API
       * @param {TempSignInRequest} tempSignInRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      tempSignIn: async (
         tempSignInRequest: TempSignInRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'tempSignInRequest' is not null or undefined
         assertParamExists('tempSignIn', 'tempSignInRequest', tempSignInRequest)
         const localVarPath = `/api/auth/temp-signin`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            tempSignInRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
      /**
       * 임시 회원가입 후 토큰을 발급한다.
       * @summary 임시 회원가입(토큰 발급) API
       * @param {TempSignUpRequest} tempSignUpRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      tempSignUp: async (
         tempSignUpRequest: TempSignUpRequest,
         options: RawAxiosRequestConfig = {},
      ): Promise<RequestArgs> => {
         // verify required parameter 'tempSignUpRequest' is not null or undefined
         assertParamExists('tempSignUp', 'tempSignUpRequest', tempSignUpRequest)
         const localVarPath = `/api/auth/temp-signup`
         // use dummy base URL string because the URL constructor only accepts absolute URLs.
         const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
         let baseOptions
         if (configuration) {
            baseOptions = configuration.baseOptions
         }

         const localVarRequestOptions = {
            method: 'POST',
            ...baseOptions,
            ...options,
         }
         const localVarHeaderParameter = {} as any
         const localVarQueryParameter = {} as any

         localVarHeaderParameter['Content-Type'] = 'application/json'

         setSearchParams(localVarUrlObj, localVarQueryParameter)
         let headersFromBaseOptions =
            baseOptions && baseOptions.headers ? baseOptions.headers : {}
         localVarRequestOptions.headers = {
            ...localVarHeaderParameter,
            ...headersFromBaseOptions,
            ...options.headers,
         }
         localVarRequestOptions.data = serializeDataIfNeeded(
            tempSignUpRequest,
            localVarRequestOptions,
            configuration,
         )

         return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
         }
      },
   }
}

/**
 * SocialLoginAPIApi - functional programming interface
 * @export
 */
export const SocialLoginAPIApiFp = function (configuration?: Configuration) {
   const localVarAxiosParamCreator =
      SocialLoginAPIApiAxiosParamCreator(configuration)
   return {
      /**
       * 닉네임 중복을 검증한다.
       * @summary 닉네임 중복 검증 API
       * @param {ValidateNickNameRequest} validateNickNameRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async checkNickName(
         validateNickNameRequest: ValidateNickNameRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<ValidateNickNameResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.checkNickName(
               validateNickNameRequest,
               options,
            )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['SocialLoginAPIApi.checkNickName']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 로그아웃한다.
       * @summary 로그아웃 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async logout(
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<LogoutResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.logout(options)
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['SocialLoginAPIApi.logout']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 토큰을 재발급한다.
       * @summary 토큰 재발급 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async reissue(
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<ReissueResponse>
      > {
         const localVarAxiosArgs =
            await localVarAxiosParamCreator.reissue(options)
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['SocialLoginAPIApi.reissue']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 추가 정보를 저장한다.
       * @summary 추가정보 API
       * @param {AdditionalInfoRequest} additionalInfoRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async signUp(
         additionalInfoRequest: AdditionalInfoRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (
            axios?: AxiosInstance,
            basePath?: string,
         ) => AxiosPromise<SignUpResponse>
      > {
         const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(
            additionalInfoRequest,
            options,
         )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['SocialLoginAPIApi.signUp']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 임시 로그인 후 토큰을 발급한다.
       * @summary 임시 로그인(토큰 발급) API
       * @param {TempSignInRequest} tempSignInRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async tempSignIn(
         tempSignInRequest: TempSignInRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
      > {
         const localVarAxiosArgs = await localVarAxiosParamCreator.tempSignIn(
            tempSignInRequest,
            options,
         )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['SocialLoginAPIApi.tempSignIn']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
      /**
       * 임시 회원가입 후 토큰을 발급한다.
       * @summary 임시 회원가입(토큰 발급) API
       * @param {TempSignUpRequest} tempSignUpRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async tempSignUp(
         tempSignUpRequest: TempSignUpRequest,
         options?: RawAxiosRequestConfig,
      ): Promise<
         (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
      > {
         const localVarAxiosArgs = await localVarAxiosParamCreator.tempSignUp(
            tempSignUpRequest,
            options,
         )
         const localVarOperationServerIndex = configuration?.serverIndex ?? 0
         const localVarOperationServerBasePath =
            operationServerMap['SocialLoginAPIApi.tempSignUp']?.[
               localVarOperationServerIndex
            ]?.url
         return (axios, basePath) =>
            createRequestFunction(
               localVarAxiosArgs,
               globalAxios,
               BASE_PATH,
               configuration,
            )(axios, localVarOperationServerBasePath || basePath)
      },
   }
}

/**
 * SocialLoginAPIApi - factory interface
 * @export
 */
export const SocialLoginAPIApiFactory = function (
   configuration?: Configuration,
   basePath?: string,
   axios?: AxiosInstance,
) {
   const localVarFp = SocialLoginAPIApiFp(configuration)
   return {
      /**
       * 닉네임 중복을 검증한다.
       * @summary 닉네임 중복 검증 API
       * @param {ValidateNickNameRequest} validateNickNameRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      checkNickName(
         validateNickNameRequest: ValidateNickNameRequest,
         options?: any,
      ): AxiosPromise<ValidateNickNameResponse> {
         return localVarFp
            .checkNickName(validateNickNameRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 로그아웃한다.
       * @summary 로그아웃 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      logout(options?: any): AxiosPromise<LogoutResponse> {
         return localVarFp
            .logout(options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 토큰을 재발급한다.
       * @summary 토큰 재발급 API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      reissue(options?: any): AxiosPromise<ReissueResponse> {
         return localVarFp
            .reissue(options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 추가 정보를 저장한다.
       * @summary 추가정보 API
       * @param {AdditionalInfoRequest} additionalInfoRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      signUp(
         additionalInfoRequest: AdditionalInfoRequest,
         options?: any,
      ): AxiosPromise<SignUpResponse> {
         return localVarFp
            .signUp(additionalInfoRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 임시 로그인 후 토큰을 발급한다.
       * @summary 임시 로그인(토큰 발급) API
       * @param {TempSignInRequest} tempSignInRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      tempSignIn(
         tempSignInRequest: TempSignInRequest,
         options?: any,
      ): AxiosPromise<string> {
         return localVarFp
            .tempSignIn(tempSignInRequest, options)
            .then((request) => request(axios, basePath))
      },
      /**
       * 임시 회원가입 후 토큰을 발급한다.
       * @summary 임시 회원가입(토큰 발급) API
       * @param {TempSignUpRequest} tempSignUpRequest
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      tempSignUp(
         tempSignUpRequest: TempSignUpRequest,
         options?: any,
      ): AxiosPromise<string> {
         return localVarFp
            .tempSignUp(tempSignUpRequest, options)
            .then((request) => request(axios, basePath))
      },
   }
}

/**
 * SocialLoginAPIApi - object-oriented interface
 * @export
 * @class SocialLoginAPIApi
 * @extends {BaseAPI}
 */
export class SocialLoginAPIApi extends BaseAPI {
   /**
    * 닉네임 중복을 검증한다.
    * @summary 닉네임 중복 검증 API
    * @param {ValidateNickNameRequest} validateNickNameRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof SocialLoginAPIApi
    */
   public checkNickName(
      validateNickNameRequest: ValidateNickNameRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return SocialLoginAPIApiFp(this.configuration)
         .checkNickName(validateNickNameRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 로그아웃한다.
    * @summary 로그아웃 API
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof SocialLoginAPIApi
    */
   public logout(options?: RawAxiosRequestConfig) {
      return SocialLoginAPIApiFp(this.configuration)
         .logout(options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 토큰을 재발급한다.
    * @summary 토큰 재발급 API
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof SocialLoginAPIApi
    */
   public reissue(options?: RawAxiosRequestConfig) {
      return SocialLoginAPIApiFp(this.configuration)
         .reissue(options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 추가 정보를 저장한다.
    * @summary 추가정보 API
    * @param {AdditionalInfoRequest} additionalInfoRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof SocialLoginAPIApi
    */
   public signUp(
      additionalInfoRequest: AdditionalInfoRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return SocialLoginAPIApiFp(this.configuration)
         .signUp(additionalInfoRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 임시 로그인 후 토큰을 발급한다.
    * @summary 임시 로그인(토큰 발급) API
    * @param {TempSignInRequest} tempSignInRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof SocialLoginAPIApi
    */
   public tempSignIn(
      tempSignInRequest: TempSignInRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return SocialLoginAPIApiFp(this.configuration)
         .tempSignIn(tempSignInRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }

   /**
    * 임시 회원가입 후 토큰을 발급한다.
    * @summary 임시 회원가입(토큰 발급) API
    * @param {TempSignUpRequest} tempSignUpRequest
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof SocialLoginAPIApi
    */
   public tempSignUp(
      tempSignUpRequest: TempSignUpRequest,
      options?: RawAxiosRequestConfig,
   ) {
      return SocialLoginAPIApiFp(this.configuration)
         .tempSignUp(tempSignUpRequest, options)
         .then((request) => request(this.axios, this.basePath))
   }
}
